-- Glint Database Schema
-- Version: 2.1.0
-- Description: This script defines the complete database schema for the Glint application.
-- It is designed to be idempotent and can be re-run safely.

-- Step 0: Drop existing objects in reverse order of dependency to ensure a clean slate.
-- First, drop the trigger, then the function it depends on.
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
DROP FUNCTION IF EXISTS public.handle_new_user();

-- Drop tables. Using CASCADE will automatically handle dependent objects like foreign keys.
DROP TABLE IF EXISTS public.user_simulation_briefings CASCADE;
DROP TABLE IF EXISTS public.user_achievements CASCADE;
DROP TABLE IF EXISTS public.task_skills CASCADE;
DROP TABLE IF EXISTS public.user_task_progress CASCADE;
DROP TABLE IF EXISTS public.achievements CASCADE;
DROP TABLE IF EXISTS public.skills CASCADE;
DROP TABLE IF EXISTS public.tasks CASCADE;
DROP TABLE IF EXISTS public.simulations CASCADE;
DROP TABLE IF EXISTS public.users CASCADE;

-- Step 1: Create the 'users' table to store public user data.
CREATE TABLE public.users (
  id UUID NOT NULL PRIMARY KEY REFERENCES auth.users(id),
  first_name TEXT,
  last_name TEXT,
  full_name TEXT,
  date_of_birth DATE,
  education_level TEXT,
  fields_of_interest TEXT[],
  primary_goal TEXT,
  biggest_challenge TEXT,
  learning_style TEXT,
  has_completed_onboarding BOOLEAN DEFAULT false
);

-- 2. Create the 'simulations' table
CREATE TABLE public.simulations (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  title TEXT NOT NULL,
  description TEXT,
  overview_description TEXT,
  overview_responsibilities TEXT[],
  overview_skills TEXT[],
  salary_range VARCHAR(255),
  icon_name TEXT,
  path TEXT NOT NULL UNIQUE,
  briefing JSONB,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- 3. Create the 'tasks' table
CREATE TABLE public.tasks (
  id BIGINT PRIMARY KEY GENERATED ALWAYS AS IDENTITY,
  simulation_id BIGINT NOT NULL REFERENCES public.simulations(id) ON DELETE CASCADE,
  title TEXT NOT NULL,
  description TEXT,
  task_order INT NOT NULL,
  definition JSONB,
  created_at TIMESTAMPTZ DEFAULT now()
);

-- 4. Create the 'skills' table
CREATE TABLE public.skills (
  id BIGINT PRIMARY KEY GENERATED ALWAYS AS IDENTITY,
  name TEXT NOT NULL UNIQUE,
  description TEXT
);

-- 5. Create the 'achievements' table
CREATE TABLE public.achievements (
  id BIGINT PRIMARY KEY GENERATED ALWAYS AS IDENTITY,
  code TEXT NOT NULL UNIQUE,
  title TEXT NOT NULL,
  description TEXT,
  icon_name TEXT
);

-- 6. Create the 'user_task_progress' table
CREATE TABLE public.user_task_progress (
  user_id UUID NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,
  task_id BIGINT NOT NULL REFERENCES public.tasks(id) ON DELETE CASCADE,
  completed_at TIMESTAMPTZ DEFAULT now(),
  PRIMARY KEY (user_id, task_id)
);

-- 7. Create the 'task_skills' join table
CREATE TABLE public.task_skills (
  task_id BIGINT NOT NULL REFERENCES public.tasks(id) ON DELETE CASCADE,
  skill_id BIGINT NOT NULL REFERENCES public.skills(id) ON DELETE CASCADE,
  PRIMARY KEY (task_id, skill_id)
);

-- 8. Create the 'user_achievements' table
CREATE TABLE public.user_achievements (
  user_id UUID NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,
  achievement_id BIGINT NOT NULL REFERENCES public.achievements(id) ON DELETE CASCADE,
  unlocked_at TIMESTAMPTZ DEFAULT now(),
  PRIMARY KEY (user_id, achievement_id)
);

-- 9. Create the 'user_simulation_briefings' table
CREATE TABLE public.user_simulation_briefings (
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  simulation_id BIGINT REFERENCES public.simulations(id) ON DELETE CASCADE,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  PRIMARY KEY (user_id, simulation_id)
);

-- 10. Set up Row Level Security (RLS) for all tables
ALTER TABLE public.users ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.simulations ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.tasks ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.skills ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.achievements ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.user_task_progress ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.task_skills ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.user_achievements ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.user_simulation_briefings ENABLE ROW LEVEL SECURITY;

-- 11. Define RLS Policies
-- 'users' table
CREATE POLICY "Public profiles are viewable by everyone." ON public.users FOR SELECT USING (TRUE);
CREATE POLICY "Users can insert their own profile." ON public.users FOR INSERT WITH CHECK (auth.uid() = id);
CREATE POLICY "Users can update own profile." ON public.users FOR UPDATE USING (auth.uid() = id);

-- 'simulations', 'tasks', 'skills', 'achievements', 'task_skills' tables (read-only for authenticated users)
CREATE POLICY "Allow read access to authenticated users" ON public.simulations FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow read access to authenticated users" ON public.tasks FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow read access to authenticated users" ON public.skills FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow read access to authenticated users" ON public.achievements FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow read access to authenticated users" ON public.task_skills FOR SELECT USING (auth.role() = 'authenticated');

-- 'user_task_progress' & 'user_achievements' tables (user-specific access)
CREATE POLICY "Allow individual access for progress and achievements" ON public.user_task_progress FOR ALL USING (auth.uid() = user_id);
CREATE POLICY "Allow individual access for achievements" ON public.user_achievements FOR ALL USING (auth.uid() = user_id);

-- 'user_simulation_briefings' table (user-specific access)
CREATE POLICY "Allow individual access for briefings" ON public.user_simulation_briefings FOR ALL USING (auth.uid() = user_id);

-- 12. Create the final 'handle_new_user' function
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.users (id, first_name, last_name, full_name, date_of_birth, education_level, fields_of_interest)
  VALUES (
    NEW.id,
    NEW.raw_user_meta_data ->> 'first_name',
    NEW.raw_user_meta_data ->> 'last_name',
    (NEW.raw_user_meta_data ->> 'first_name') || ' ' || (NEW.raw_user_meta_data ->> 'last_name'),
    (NEW.raw_user_meta_data ->> 'date_of_birth')::DATE,
    NEW.raw_user_meta_data ->> 'education_level',
    (SELECT array_agg(interest) FROM jsonb_array_elements_text(NEW.raw_user_meta_data -> 'fields_of_interest') AS t(interest))
  );
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 13. Create the trigger for the function
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();

-- 14. Create the final 'get_user_dashboard_data' function
CREATE OR REPLACE FUNCTION public.get_user_dashboard_data()
RETURNS JSONB
LANGUAGE plpgsql
AS $$
DECLARE
    v_user_id UUID := auth.uid();
    all_simulations_json JSONB;
    simulation_progress_json JSONB;
    unlocked_skills_json JSONB;
    unlocked_achievements_json JSONB;
BEGIN
    -- 1. Get all simulations
    SELECT jsonb_agg(s.*)
    INTO all_simulations_json
    FROM simulations s;

    -- 2. Get progress for simulations the user has started
    SELECT jsonb_agg(progress)
    INTO simulation_progress_json
    FROM (
        SELECT
            t.simulation_id,
            COUNT(t.id) AS total_tasks,
            COUNT(utp.task_id) AS completed_tasks
        FROM tasks t
        LEFT JOIN user_task_progress utp ON t.id = utp.task_id AND utp.user_id = v_user_id
        GROUP BY t.simulation_id
    ) AS progress;

    -- 3. Get all skills unlocked by the user
    SELECT jsonb_agg(DISTINCT sk.name)
    INTO unlocked_skills_json
    FROM user_task_progress utp
    JOIN task_skills ts ON utp.task_id = ts.task_id
    JOIN skills sk ON ts.skill_id = sk.id
    WHERE utp.user_id = v_user_id;

    -- 4. Get all achievements unlocked by the user
    SELECT jsonb_agg(DISTINCT a.code)
    INTO unlocked_achievements_json
    FROM user_achievements ua
    JOIN achievements a ON ua.achievement_id = a.id
    WHERE ua.user_id = v_user_id;

    -- 5. Combine and return all data
    RETURN jsonb_build_object(
        'all_simulations', COALESCE(all_simulations_json, '[]'::jsonb),
        'simulation_progress', COALESCE(simulation_progress_json, '[]'::jsonb),
        'unlocked_skills', COALESCE(unlocked_skills_json, '[]'::jsonb),
        'unlocked_achievements', COALESCE(unlocked_achievements_json, '[]'::jsonb)
    );
END;
$$; 